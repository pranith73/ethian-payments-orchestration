# 2.11 Beginner Examples (Hands-on Mental Model)

This page gives beginner-friendly examples that connect the Section 2 concepts:
Entities → relationships → state machines → ledger postings → events.

---

## 2.11.1 Example A — Simple Invoice Payment (happy path)

**Goal:** Customer pays an invoice successfully.

### Actors / Entities
- Merchant (owns the invoice + payment)
- Customer (payer identity)
- Invoice (amount due)
- Payment (money movement lifecycle)
- Ledger (double-entry truth)
- Domain Events (communication)

### Starting state
- Invoice created and ISSUED with amountDue = `USD 12.99`
- Payment does not exist yet

### Steps
1) Merchant issues Invoice
   - Invoice state: `ISSUED`

2) Customer initiates Payment for that Invoice
   - Payment state: `CREATED`
   - Payment references: `invoiceId`, `merchantId`, `customerId` (optional)

3) Processor authorizes funds
   - Payment state: `AUTHORIZED`
   - Domain event candidate: `PaymentAuthorized`

4) Funds captured
   - Payment state: `CAPTURED`
   - Domain event: `PaymentCaptured`

5) Invoice is updated by applying captured amount
   - If captured total == amountDue → Invoice state: `PAID`
   - Domain event: `InvoicePaid`

6) Ledger posting occurs for capture (conceptual)
   - Balanced posting must be created (sum debits == sum credits)
   - Example (conceptual accounts):
     - Debit: Cash / Clearing (Asset)
     - Credit: Merchant Receivable or Merchant Payable (Liability) OR Revenue mapping depending on accounting model
   - Invariant enforced: **Every ledger posting must be balanced** (2.7 / 2.8)

7) Settlement happens later (separate lifecycle)
   - Settlement state might go: `PENDING` → `PAID`
   - Settlement posting updates ledger accounts accordingly

---

## 2.11.2 Example B — Payment Failure + Retry

**Goal:** First attempt fails, second attempt succeeds.

### Starting state
- Invoice is `ISSUED`
- Payment is created referencing invoice

### Steps
1) Payment created → `CREATED`
2) Authorization fails or capture fails
   - Payment state: `FAILED`
   - Invariant: Failed payments must not impact ledger (2.8)
   - Domain event: `PaymentFailed`

3) Retry occurs (either same Payment with a new attempt or a new Payment, depending on model)
   - Payment attempt tracked (optional concept from 2.1)
   - Second attempt reaches `CAPTURED`

4) Invoice transitions
   - `ISSUED` → `PAID` if total captured equals amountDue
   - Or `ISSUED` → `PARTIALLY_PAID` if partial capture

---

## 2.11.3 Example C — Partial Payments

**Goal:** Invoice is paid across two captures.

### Starting state
- Invoice amountDue = `USD 100.00`

### Steps
1) Payment #1 captured for `USD 60.00`
   - Invoice state: `PARTIALLY_PAID`
   - Ledger posting created for capture amount

2) Payment #2 captured for `USD 40.00`
   - Invoice state: `PAID`
   - Ledger posting created for capture amount

### Key invariant
- Invoice cannot be PAID unless total captured == amountDue (2.8)

---

## 2.11.4 Example D — Refund after Capture

**Goal:** Customer receives a refund after a successful payment.

### Steps
1) Payment is `CAPTURED`
2) Refund requested
   - Refund entity created under Payment
   - Refund state: `REQUESTED`

3) Refund succeeds
   - Refund state: `SUCCEEDED`
   - Domain event: `RefundSucceeded`

4) Ledger posting for refund (conceptual)
   - Balanced posting reversing the money movement
   - Invariant: Refund total must not exceed captured amount (2.8)

---

## 2.11.5 What beginners should remember

- **Invoice** = money expected (amount due)
- **Payment** = lifecycle of money movement (auth/capture/fail/refund)
- **Ledger** = financial truth (double-entry, balanced, append-only)
- **Settlement** = payout happens later than capture
- **Events** = how changes are communicated between services and to webhooks

Next: see **2.12 Interview Hooks**.